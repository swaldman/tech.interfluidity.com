<?xml version='1.0' encoding='UTF-8'?>
<rss 
version="2.0" xmlns:iffy="http://tech.interfluidity.com/xml/iffy/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>tech — interfluidity</title>
    <link>https://tech.interfluidity.com/index.html</link>
    <description><![CDATA[Feed for blog 'tech — interfluidity', generated by unstatic]]></description>
    <language>en-us</language>
    <lastBuildDate>Tue, 28 Jan 2025 22:09:37 -0500</lastBuildDate>
    <generator>https://github.com/swaldman/unstatic</generator>
    <docs>https://cyber.harvard.edu/rss/rss.html</docs>
    <atom:link
    type="application/rss+xml" rel="self" href="https://tech.interfluidity.com/2023/12/06/apis-against-dependent-types-in-scala/index.rss"/>
    <iffy:curation>
      <iffy:single/>
    </iffy:curation>
    <iffy:completeness>Content</iffy:completeness>
    <item>
      <pubDate>Wed, 6 Dec 2023 16:00:00 -0500</pubDate>
      <guid isPermalink="true">
        https://tech.interfluidity.com/2023/12/06/apis-against-dependent-types-in-scala/index.html
      </guid>
      <description>
        <![CDATA[Scala supports instance-dependent types, which is very cool! So I can define... class Human( name : String ):
  case class Tooth( num : Int ):
    override def toString(): String = s"${name}'s #${num} tooth"
    
  val teeth = Set.from( (1 to 32).map( Tooth.apply ) )
  def brush( myTeeth : Set[Tooth] ) : Unit = println(s"fluoride goodness for ${name}")
  
val me = new Human("Steve")
val you = new Human("Awesome")

me.brush( me.teeth )
//me.brush( you.teeth ) // gross! doesn't compile. (as it...]]>
      </description>
      <link>https://tech.interfluidity.com/2023/12/06/apis-against-dependent-types-in-scala/index.html</link>
      <title>APIs against dependent types in Scala</title>
      <dc:creator><![CDATA[Steve Randy Waldman]]></dc:creator>
      <content:encoded>
        <![CDATA[<article class="presentation-rss">
 <div class="entry-header">
 </div>
 <div class="entry-body">
  <div class="flexmark markdown">
   <p>Scala supports instance-dependent types, which is very cool! So I can define...</p>
   <pre><code class="language-scala">class Human( name : String ):
  case class Tooth( num : Int ):
    override def toString(): String = s"${name}'s #${num} tooth"
    
  val teeth = Set.from( (1 to 32).map( Tooth.apply ) )
  def brush( myTeeth : Set[Tooth] ) : Unit = println(s"fluoride goodness for ${name}")
  
val me = new Human("Steve")
val you = new Human("Awesome")

me.brush( me.teeth )
//me.brush( you.teeth ) // gross! doesn't compile. (as it should not!)
</code></pre>
   <p>My teeth and your teeth are different types, even though they are of the same class. The identity of the <em>enclosing instance</em> is a part of the type.</p>
   <p>And we see here how that can be useful! Often inner classes represent internal structures that should mostly be managed by their enclosing instance. It's good that the compiler pushes back against code in which you might brush my teeth or pump my heart!</p>
   <p>But sometimes inner instances are not so internal, or even if they are, an external thing might have business interacting with it. The virtual human we are modeling might have need of a dentist or a cadiologist.</p>
   <p>Scala's type system doesn't prevent external things from accessing inner class instances, it just demands you do it via a correct type.</p>
   <p>I know of two ways to define external APIs against instance-dependent types. First, Scala supports <em>projection types</em>, like <code>Human#Teeth</code>. Where an ordinary dot-separated path would have required me to identify some particular instance, <code>Human#Teeth</code> matches the tooth of <em>any</em> human.</p>
   <p>A second way to hit instance-dependent types from an external API is to require the caller to identify the instance in the call, and then let the type of a later argument to the same call include the identified instance. I think it's kind of wild that Scala supports this. It's an example where the type of arguments to a statically declared function is effectively determined at runtime. You don't even need separate argument lists, although I think I prefer them.</p>
   <pre><code class="language-scala">class Dentist:
  def checkByProjection( tooth : Human#Tooth ) : Unit = println( s"Found ${tooth} (by projection)" )
  def checkByIdentifying( human : Human)( tooth : human.Tooth ) : Unit = println( s"Found ${tooth} (by identification)" )

val d  = new Dentist

// API by projection
d.checkByProjection( me.teeth.head )
d.checkByProjection( you.teeth.head )

// API by identification
d.checkByIdentifying( me )( me.teeth.head )
d.checkByIdentifying( you )( you.teeth.head )

// d.checkByIdentifying( me )( you.teeth.head ) // does not compile, as it should not
// d.checkByIdentifying( you )( me.teeth.head ) // does not compile, as it should not
</code></pre>
   <p>I've used projection types a lot, over the eons. I know some people think that any need for external APIs against inner types is code smell or something. But I've found a variety of places where they seem to make sense, and the "do it right" workarounds (e.g. define some instance-independent abstract base type for the inner things, and write external APIs against that) just create busy work and maintenance complexity.</p>
   <p>Nevertheless, in some corner cases, projection types <a href="https://github.com/lampepfl/dotty/issues/18655">aren't completely supported</a>, and my sense is that much of the Scala community considers them icky (like brushing someone else's teeth).</p>
   <p>Sometimes you need to write APIs against inner types by identification anyway, because you need to know stuff about the enclosing instance (which inner instances don't disclose unless they declare an explicit reference).</p>
   <p>But sometimes you don't need to be told the identity of the outer instance (because it's not relevant to what you are doing, or because the inner instance discloses a reference explicitly).</p>
   <p>Are projection types icky and it best to just standardize on requiring explicit identification of enclosing instances?</p>
   <p>Or are projection types a cool trick we should delight in using?</p>
   <p>Enquiring minds want to know!</p>
   <hr>
   <p>(This blog doesn't support comments yet, but you can reply to <a href="https://zirk.us/@interfluidity/111535483316429524">this post</a> on Mastodon.)</p>
  </div>
 </div>
 <div class="entry-footer">
  <div class="post-metainfo">
   <hr>
   <div>
    by Steve Randy Waldman on 2023-12-06 @ <a href="https://tech.interfluidity.com/2023/12/06/apis-against-dependent-types-in-scala/index.html" class="pubtime">04:00 PM EST</a>
   </div>
  </div>
 </div>
</article>
<div class="after-article">
</div><!-- after-article -->]]>
      </content:encoded>
    </item>
  </channel>
</rss>
