<?xml version='1.0' encoding='UTF-8'?>
<rss 
version="2.0" xmlns:iffy="http://tech.interfluidity.com/xml/iffy/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>tech — interfluidity</title>
    <link>https://tech.interfluidity.com/index.html</link>
    <description><![CDATA[Feed for blog 'tech — interfluidity', generated by unstatic]]></description>
    <language>en-us</language>
    <lastBuildDate>Mon, 6 Jan 2025 20:33:36 -0500</lastBuildDate>
    <generator>https://github.com/swaldman/unstatic</generator>
    <docs>https://cyber.harvard.edu/rss/rss.html</docs>
    <atom:link
    type="application/rss+xml" rel="self" href="https://tech.interfluidity.com/2023/05/20/pdfcat-as-a-scala-script/index.rss"/>
    <iffy:curation>
      <iffy:single/>
    </iffy:curation>
    <iffy:completeness>Content</iffy:completeness>
    <item>
      <pubDate>Sat, 20 May 2023 17:00:00 -0400</pubDate>
      <guid isPermalink="true">https://tech.interfluidity.com/2023/05/20/pdfcat-as-a-scala-script/index.html</guid>
      <description>
        <![CDATA[I am really enjoying scripting in Scala with scala-cli. Scala has long supported scripting in theory, but for your scripts to run, all the dependencies had to be preinstalled in your CLASSPATH. That rendered the feature not so useful. Under scala-cli, however, dependencies are delightfully automanaged for your script. This has rendered JVM scripting practical and convenient for me. I find that psychologically this is a BFD. It dissolves the boundary between app and library. Usually, I want to...]]>
      </description>
      <link>https://tech.interfluidity.com/2023/05/20/pdfcat-as-a-scala-script/index.html</link>
      <title>pdfcat as a Scala script</title>
      <dc:creator><![CDATA[Steve Randy Waldman]]></dc:creator>
      <content:encoded>
        <![CDATA[<article class="presentation-rss">
 <div class="entry-header">
 </div>
 <div class="entry-body">
  <div class="flexmark markdown">
   <p>I am really enjoying scripting in Scala with <a href="https://scala-cli.virtuslab.org/"><code>scala-cli</code></a>.</p>
   <p>Scala has long supported scripting in theory, but for your scripts to run, all the dependencies had to be preinstalled in your <code>CLASSPATH</code>. That rendered the feature not so useful. Under <code>scala-cli</code>, however, dependencies are delightfully automanaged for your script. This has rendered JVM scripting practical and convenient for me.</p>
   <p>I find that psychologically this is a BFD. It dissolves the boundary between app and library. Usually, I want to get something done, I look for an app. If I want to merge a bunch of PDFs together, I might fire up <i>Adobe Acrobat</i>, curse myself, and mess around until I figure out how you do that.</p>
   <p>However, the Java <a href="https://pdfbox.apache.org/">PDFBox</a> library exists. (<a href="https://itextpdf.com/">itextpdf</a> too!) With easy scripting, the library can substitute for the app. A glance at a <a href="https://www.tutorialspoint.com/pdfbox/pdfbox_merging_multiple_pdf_documents.htm">tutorial</a> on how to merge PDFs with PDFBox and we were <a href="https://github.com/swaldman/scalascripts-misc/blob/main/bin/pdfcat">off to the races</a>.</p>
   <p>The meaningful code is trivial:</p>
   <pre><code class="language-scala">val files = args.map(fn =&gt; new File(fn))
val merger = new PDFMergerUtility();
merger.setDestinationFileName(args.last)
files.init.foreach( merger.addSource )
merger.mergeDocuments()
</code></pre>
   <p>The <a href="https://github.com/swaldman/scalascripts-misc/blob/main/bin/pdfcat">full script</a> is longer than this, of course, but the rest is sanity-checking the command line and aborting if it isn't right.</p>
   <p>In fact, I often find command-line parsing outweighs functional code when I write scripts. Of course that's all optional — you can skip a nice command line if you really mean to script a one-off. But it is great to retain the capacity to solve probems you've already solved instantly on a nice command line. And it's great practice with the Scala ecosystem's rich set of command-line parsing libraries.</p>
   <p>A few days ago I needed to quickly serve a directory by HTTP from my laptop. There's some Python command I've used for that in the past. I'd have to look it up, and figure out how to get it to bind to the laptop's public interface rather than localhost. It was quick instead to script up Li Haoyi's <a href="https://github.com/com-lihaoyi/cask"><code>cask</code></a> library, and build a nice command line with <a href="https://ben.kirw.in/decline/"><code>decline</code></a>. Check out <a href="https://github.com/swaldman/scalascripts-misc/blob/main/bin/http-serve"><code>http-serve</code></a>.</p>
  </div>
 </div>
 <div class="entry-footer">
  <div class="post-metainfo">
   <hr>
   <div>
    by Steve Randy Waldman on 2023-05-20 @ <a href="https://tech.interfluidity.com/2023/05/20/pdfcat-as-a-scala-script/index.html" class="pubtime">05:00 PM EDT</a>
   </div>
  </div>
 </div>
</article>
<div class="after-article">
</div><!-- after-article -->]]>
      </content:encoded>
    </item>
  </channel>
</rss>
