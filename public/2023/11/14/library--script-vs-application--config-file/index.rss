<?xml version='1.0' encoding='UTF-8'?>
<rss 
version="2.0" xmlns:iffy="http://tech.interfluidity.com/xml/iffy/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>tech — interfluidity</title>
    <link>https://tech.interfluidity.com/index.html</link>
    <description><![CDATA[Feed for blog 'tech — interfluidity', generated by unstatic]]></description>
    <language>en-us</language>
    <lastBuildDate>Mon, 6 Jan 2025 20:40:31 -0500</lastBuildDate>
    <generator>https://github.com/swaldman/unstatic</generator>
    <docs>https://cyber.harvard.edu/rss/rss.html</docs>
    <atom:link
    type="application/rss+xml" rel="self" href="https://tech.interfluidity.com/2023/11/14/library--script-vs-application--config-file/index.rss"/>
    <iffy:curation>
      <iffy:single/>
    </iffy:curation>
    <iffy:completeness>Content</iffy:completeness>
    <item>
      <pubDate>Tue, 14 Nov 2023 12:35:00 -0500</pubDate>
      <guid isPermalink="true">
        https://tech.interfluidity.com/2023/11/14/library--script-vs-application--config-file/index.html
      </guid>
      <description>
        <![CDATA[TL; DR: For Scala apps, instead of installing applications and writing separate config files, why not do config like this? #!/usr/bin/env -S scala-cli shebang

//> using dep "com.example::cool-app:1.0.0"

val config = coolapp.Config(
  name = "Fonzie",                    // the name of your installation
  apparel = coolapp.Apparel.Leather,  // see elements defined in coolapp.Apparel
  gesture = coolapp.Gesture.ThumbsUp, // see elements defined in coolapp.Gesture
  reference = "Very dated, old...]]>
      </description>
      <link>https://tech.interfluidity.com/2023/11/14/library--script-vs-application--config-file/index.html</link>
      <title>(Library + Script) vs (Application + Config File)</title>
      <dc:creator><![CDATA[Steve Randy Waldman]]></dc:creator>
      <content:encoded>
        <![CDATA[<article class="presentation-rss">
 <div class="entry-header">
 </div>
 <div class="entry-body">
  <div class="flexmark markdown">
   <p><strong>TL; DR:</strong></p>
   <p>For Scala apps, instead of installing applications and writing separate config files, why not do config like this?</p>
   <pre><code class="language-scala">#!/usr/bin/env -S scala-cli shebang

//&gt; using dep "com.example::cool-app:1.0.0"

val config = coolapp.Config(
  name = "Fonzie",                    // the name of your installation
  apparel = coolapp.Apparel.Leather,  // see elements defined in coolapp.Apparel
  gesture = coolapp.Gesture.ThumbsUp, // see elements defined in coolapp.Gesture
  reference = "Very dated, old man.", // a string to help users identify your character
  port = 8765                         // the port on which the app will run
)

coolapp.start( config )
</code></pre>
   <hr>
   <p>Once upon a time, I spent a very great deal of time supporting and integrating multiple config formats into my work. I used to describe <a href="https://www.mchange.com/projects/c3p0/">c3p0</a> as a configuration project attached to a connection pool.</p>
   <p>Lately, though, I find I am skipping any support of config files. I mostly write Scala, and Scala case classes strike me as a pretty good configuration format.</p>
   <ul>
    <li>
     <p>Since you can intitialize case classes with named arguments, <code>key = value</code>, they can be made literate and intuitive.</p></li>
    <li>
     <p>They support rich comments, because the Scala language supports comments.</p></li>
    <li>
     <p>With simple string or integer values, they are as simple as most config formats.</p></li>
   </ul>
   <p>Case-class config is extremely flexible, because your values are specified in a general purpose programming language, and can include variables or functions. And you get compile-time feedback for misconfigurations.</p>
   <p>When I first became enamored with case-classes-as-config, I <a href="https://github.com/swaldman/audiofluidity">wrote</a> a special purpose bootstrap app that would compile a file containing a case-class-instance-as-config, then use Java reflection to load it from a container.</p>
   <pre><code class="language-scala">val podcast : Podcast =
    Podcast(
      mainUrl                = "https://superpodcast.audiofluidity.com/",
      title                  = "Superpodcast",
      description            = """｜&lt;p&gt;Superpodcast is the best podcast you've ever heard.&lt;/p&gt;
                                  ｜
                                  ｜&lt;p&gt;In fact, you will never hear it.&lt;/p&gt;""".stripMargin,
      guidPrefix             = "com.audiofluidity.superpodcast-",
      shortOpaqueName        = "superpodcast",
      mainCoverImageFileName = "some-cover-art.jpg",
      editorEmail            = "asshole@audiofluidity.com",
      defaultAuthorEmail     = "asshole@audiofluidity.com",
      itunesCategories       = immutable.Seq( ItunesCategory.Comedy ),
      mbAdmin                = Some(Admin(name="Asshole", email="asshole@audiofluidity.com")),
      mbLanguage             = Some(LanguageCode.EnglishUnitedStates),
      mbPublisher            = Some("Does Not Exist, LLC"),
      episodes               = episodes
    )
</code></pre>
   <p>In more recent projects, I've just used either <a href="https://scala-cli.virtuslab.org/"><code>scala-cli</code></a> or <a href="https://mill-build.com/mill/Intro_to_Mill.html"><code>mill</code></a> as a runner. Sometimes I've left the definition of a stub case-class instance in the <code>src</code> directory for users to fill in, as in <a href="https://github.com/swaldman/fossilphant/blob/main/fossilphant/src/config.scala"><code>fossilphant</code></a>. Other times I've defined abstract main classes, asking users to extend them by overriding a method that supplies config as a case class instance, as in <a href="https://github.com/swaldman/unify-rss/blob/2f6305568f8b53e63fa5c16d663db44b0b565288/main/com/mchange/unifyrss/AbstractDaemonMain.scala"><code>unify-rss</code></a>.</p>
   <pre><code class="language-scala">package com.mchange.unifyrss

import scala.collection.*

import zio.*

abstract class AbstractDaemonMain extends ZIOAppDefault:

  def appConfig : AppConfig

  override def run =
    for
      mergedFeedRefs   &lt;- initMergedFeedRefs( appConfig )
      _                &lt;- periodicallyResilientlyUpdateAllMergedFeedRefs( appConfig, mergedFeedRefs )
      _                &lt;- ZIO.logInfo(s"Starting up unify-rss server on port ${appConfig.servicePort}")
      exitCode         &lt;- server( appConfig, mergedFeedRefs )
    yield exitCode
</code></pre>
   <p>So far, I've just instantiated these with concrete <code>object</code>s <a href="https://github.com/swaldman/unify-rss/blob/24cc87b4e6dc6c5a574497c3004fbd00d41f91d8/main/InterfluidityMain.scala">in Scala source files</a>.</p>
   <p>But it strikes me that a natural refinement would be to design libraries with entry points that accept a case-class-config object as an argument, and expect users to deploy them as e.g. <code>scala-cli</code> scripts. Just something like:</p>
   <pre><code class="language-scala">#!/usr/bin/env -S scala-cli shebang

//&gt; using dep "com.example::cool-app:1.0.0"

val config = coolapp.Config(
  name = "Fonzie",                    // the name of your installation
  apparel = coolapp.Apparel.Leather,  // see elements defined in coolapp.Apparel
  gesture = coolapp.Gesture.ThumbsUp, // see elements defined in coolapp.Gesture
  reference = "Very dated, old man.", // a string to help users identify your character
  port = 8765                         // the port on which the app will run
)

coolapp.start( config )
</code></pre>
   <p>There is a bit of ceremony, and a bit that might intimidate people not accustomed to Scala syntax and tools. But "standard" config file formats get complicated and intimidating too. Here users get quick feedback if they don't pick a valid value without developers having to write special validation logic. Users are still just deploying a text file, as they would with ordinary config.</p>
   <p>If your priority is 100% user experience, then using a standard (or <a href="https://kdl.dev/">new and improved</a>, ht <a href="https://notes.billmill.org/link_blog/2023/11/KDL_-_a_config_language.html">Bill Mill</a>) config file format, then hand-writing informative, fail-fast validation logic is going to be a better way to go.</p>
   <p>But your priority should not always be user experience! Not all software development should take the form of a "product" developed at a high cost that will then be amortized over sales to or adoption by a very large number of users.</p>
   <p>Software is a form of collaboration, and often that collaboration will be more productive and evolve more quickly when "users" are understood to be reasonably capable and informed, so developers don't expand the scope of their work and their maintenance burden in order to render the application accessible to the most intimidated potential users.</p>
   <p>Obviously it depends what you are doing! But if there is going to be a config file at all, you are already collaborating with a pretty restricted set of people who are okay with setting up and editing an inevitably arcane text file.</p>
   <p>For many applications and collaborations, maintainability at moderate cost in time and money and speed of evolution, are important. For these applications, when written in an expressive, strongly-typed language like Scala, defining config as a data structure in a script, that then executes an app defined as an entry point to a library, strike me as a pretty good way to go.</p>
  </div>
 </div>
 <div class="entry-footer">
  <div class="post-metainfo">
   <hr>
   <div>
    by Steve Randy Waldman on 2023-11-14 @ <a href="https://tech.interfluidity.com/2023/11/14/library--script-vs-application--config-file/index.html" class="pubtime">12:35 PM EST</a>
   </div>
  </div>
 </div>
</article>
<div class="after-article">
</div><!-- after-article -->]]>
      </content:encoded>
    </item>
  </channel>
</rss>
