<?xml version='1.0' encoding='UTF-8'?>
<rss 
version="2.0" xmlns:iffy="http://tech.interfluidity.com/xml/iffy/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>tech — interfluidity</title>
    <link>https://tech.interfluidity.com/index.html</link>
    <description><![CDATA[Feed for blog 'tech — interfluidity', generated by unstatic]]></description>
    <language>en-us</language>
    <lastBuildDate>Sat, 30 Aug 2025 18:53:48 -0400</lastBuildDate>
    <generator>https://github.com/swaldman/unstatic</generator>
    <docs>https://cyber.harvard.edu/rss/rss.html</docs>
    <atom:link
    type="application/rss+xml" rel="self" href="https://tech.interfluidity.com/2023/08/30/suppressing-bloop-for-scala-cli-managed-services/index.rss"/>
    <iffy:curation>
      <iffy:single/>
    </iffy:curation>
    <iffy:completeness>Content</iffy:completeness>
    <item>
      <pubDate>Wed, 30 Aug 2023 15:45:00 -0400</pubDate>
      <guid isPermalink="true">
        https://tech.interfluidity.com/2023/08/30/suppressing-bloop-for-scala-cli-managed-services/index.html
      </guid>
      <description>
        <![CDATA[I am a huge fan of scala-cli. Among its many virtues, it reproduces the ergonomics of an interpreted language for compiled, super typesafe, Scala. (Java too!) Recently, I've written custom services that I execute using scala-cli run, and then deploy directly as systemd units. Here's a snippet of how I used to do this: ...

[Service]
Type=simple
User=unify-rss
Group=unify-rss
WorkingDirectory=/home/unify-rss/development/gitproj/unify-rss
ExecStart=scala-cli run main
...
 I noticed, however,...]]>
      </description>
      <link>https://tech.interfluidity.com/2023/08/30/suppressing-bloop-for-scala-cli-managed-services/index.html</link>
      <title>Suppressing bloop for scala-cli managed services</title>
      <dc:creator><![CDATA[Steve Randy Waldman]]></dc:creator>
      <content:encoded>
        <![CDATA[<article class="presentation-rss">
 <div class="entry-header">
 </div>
 <div class="entry-body">
  <div class="flexmark markdown">
   <p>I am a huge fan of <a href="https://scala-cli.virtuslab.org/">scala-cli</a>.</p>
   <p>Among its many virtues, it reproduces the ergonomics of an interpreted language for compiled, super typesafe, Scala. (Java too!)</p>
   <p>Recently, I've <a href="https://tech.interfluidity.com/2023/07/29/building-a-resilient-rss-feed-unifier-with-zio/index.html">written custom services</a> that I execute using <code>scala-cli run</code>, and then deploy directly as <a href="https://www.digitalocean.com/community/tutorials/understanding-systemd-units-and-unit-files">systemd units</a>.</p>
   <p>Here's a snippet of <a href="https://github.com/swaldman/unify-rss/blob/2f4e58b2a68c5d0313548306450883b603805739/unify-rss.service">how I used to</a> do this:</p>
   <pre><code class="language-plaintext">...

[Service]
Type=simple
User=unify-rss
Group=unify-rss
WorkingDirectory=/home/unify-rss/development/gitproj/unify-rss
ExecStart=scala-cli run main
...
</code></pre>
   <p>I noticed, however, where I expected one long-running java process for a service's dedicated user, I ended up with two! In addition to my own application, a service called <code>bloop.Bloop</code> was running as well.</p>
   <p>JVMs are not exactly lightweight, and I don't want double the fun when running a service.</p>
   <p><a href="https://scalacenter.github.io/bloop/">bloop</a> is a Scala build service that many different editors, build systems, and other tools use to efficiently, incrementally, compile and run scala code. It runs as a persistent background process, which external tools tools can trigger with commands to build or execute the codebase, recompiling only what is necessary given what has changed.</p>
   <p>This is great for fast iteration during development, but unwieldy (and potentially increases a threat surface area) during deployment of persistent services.</p>
   <p>Fortunately, <code>scala-cli</code>, you can turn <code>bloop</code> off. <code>scala-cli</code> then falls back to the plain old Scala compiler to rebuild your application. It retains its core ergonomics: You can edit, then run, without any sort of compile / assemble / publish ceremony. The first run after a change might take a bit longer than it would have with <code>bloop</code>.</p>
   <p>Here is a snippet (slightly simplified) of <a href="https://github.com/swaldman/unify-rss/blob/fdda4547655e52036d55eff765e642251f9d4222/unify-rss.service">my current systemd unit</a>.</p>
   <pre><code class="language-plaintext">...

[Service]
Type=simple
User=unify-rss
Group=unify-rss
WorkingDirectory=/home/unify-rss/development/gitproj/unify-rss
ExecStart=scala-cli run --server=false main
...
</code></pre>
   <p>Note the <code>--server=false</code> argument to <code>scala-cli run</code>.</p>
   <p>Executing the service works just the same as before, rebuilding if necessary. But now no <code>bloop</code> service squanders precious server-side memory.</p>
   <p>My application is small enough that the additional build time is not an issue. The only visible difference when running <code>scala-cli</code> is that, when <code>bloop</code> is enabled and something has changed, I would see a message like</p>
   <pre><code class="language-plaintext">Compiling project (Scala 3.3.0, JVM)
Compiled project (Scala 3.3.0, JVM)
</code></pre>
   <p>With the <code>--server=false</code> flag gone (it defaults to true), that message disappears.</p>
   <p>But changes still recompile, and everything works great.</p>
   <hr>
   <p><strong>Note:</strong> the <code>--server=false</code> argument has to come <em>after</em> the <code>run</code> subcommand. Otherwise...</p>
   <pre><code class="language-plaintext">$ scala-cli --server=false run main
[error]  run is not a scala-cli sub-command and it is not a valid path to an input file or directory.
Try viewing the relevant help to see the list of available sub-commands and options.
  scala-cli --help
</code></pre>
   <p>The error message is unhelpfully mistaken. <code>run</code> in fact is a valid <code>scala-cli</code> subcommand. But <code>--server</code> is not a valid command-line option to the base <code>scala-cli</code> command, it is a valid command-line option to <code>scala-cli run</code>.</p>
   <pre><code class="language-plaintext">$ scala-cli --version
Scala CLI version: 1.0.4
Scala version (default): 3.3.0
</code></pre>
  </div>
 </div>
 <div class="entry-footer">
  <div class="post-metainfo">
   <hr>
   <div>
    by Steve Randy Waldman on 2023-08-30 @ <a href="https://tech.interfluidity.com/2023/08/30/suppressing-bloop-for-scala-cli-managed-services/index.html" class="pubtime">03:45 PM EDT</a>
   </div>
  </div>
 </div>
</article>
<div class="after-article">
</div><!-- after-article -->]]>
      </content:encoded>
    </item>
  </channel>
</rss>
