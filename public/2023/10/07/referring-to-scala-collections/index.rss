<?xml version='1.0' encoding='UTF-8'?>
<rss 
version="2.0" xmlns:iffy="http://tech.interfluidity.com/xml/iffy/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>tech — interfluidity</title>
    <link>https://tech.interfluidity.com/index.html</link>
    <description><![CDATA[Feed for blog 'tech — interfluidity', generated by unstatic]]></description>
    <language>en-us</language>
    <lastBuildDate>Tue, 28 Jan 2025 01:31:05 -0500</lastBuildDate>
    <generator>https://github.com/swaldman/unstatic</generator>
    <docs>https://cyber.harvard.edu/rss/rss.html</docs>
    <atom:link
    type="application/rss+xml" rel="self" href="https://tech.interfluidity.com/2023/10/07/referring-to-scala-collections/index.rss"/>
    <iffy:curation>
      <iffy:single/>
    </iffy:curation>
    <iffy:completeness>Content</iffy:completeness>
    <item>
      <pubDate>Sat, 7 Oct 2023 17:45:00 -0400</pubDate>
      <guid isPermalink="true">https://tech.interfluidity.com/2023/10/07/referring-to-scala-collections/index.html</guid>
      <description>
        <![CDATA[TL; DR: Prefer import scala.collection.{immutable,mutable}
 Over the eons, I developed a habit of using the following import import scala.collection.*
 to set up my use of Scala collections. Then I can refer to collections in a very clear longhand. For example: val alphamap = immutable.Map( "A" -> "Apple", "B" -> "Baby", "C" -> "Candy" )
 or, much less frequently: val scratchpad = mutable.Map( "Title" -> "Untitled" )
 I like referring explicitly to collections as mutable.Thing or...]]>
      </description>
      <link>https://tech.interfluidity.com/2023/10/07/referring-to-scala-collections/index.html</link>
      <title>Referring to Scala collections</title>
      <dc:creator><![CDATA[Steve Randy Waldman]]></dc:creator>
      <content:encoded>
        <![CDATA[<article class="presentation-rss">
 <div class="entry-header">
 </div>
 <div class="entry-body">
  <div class="flexmark markdown">
   <p><strong>TL; DR:</strong> Prefer</p>
   <pre><code class="language-scala">import scala.collection.{immutable,mutable}
</code></pre>
   <hr>
   <p>Over the eons, I developed a habit of using the following import</p>
   <pre><code class="language-scala">import scala.collection.*
</code></pre>
   <p>to set up my use of Scala collections.</p>
   <p>Then I can refer to collections in a very clear longhand. For example:</p>
   <pre><code class="language-scala">val alphamap = immutable.Map( "A" -&gt; "Apple", "B" -&gt; "Baby", "C" -&gt; "Candy" )
</code></pre>
   <p>or, much less frequently:</p>
   <pre><code class="language-scala">val scratchpad = mutable.Map( "Title" -&gt; "Untitled" )
</code></pre>
   <p>I <em>like</em> referring explicitly to collections as <code>mutable.Thing</code> or <code>immutable.Thing</code>. Yes it's more typing, but it's very clear.</p>
   <p>But recently the practice has caused some hassles, and I've realized it's not great.</p>
   <p>Consider this little <a href="https://scala-cli.virtuslab.org/">scala-cli</a> application:</p>
   <pre><code class="language-scala">//&gt; using scala 3.3.1

trait Hat:
  def tickets : Set[String]

object HatApp:
  import scala.collection.*
  import scala.util.Random

  val hat = new Hat:
    def tickets : Set[String] = Set("Alice", "Bob", "Carol")

  @main  
  def winner = println( Random.shuffle(hat.tickets.toList).head )
</code></pre>
   <p>Try running it, and oops!</p>
   <pre><code class="language-plaintext">Compiling project (Scala 3.3.1, JVM)
[error] ./unqualified-collections.scala:11:9
[error] error overriding method tickets in trait Hat of type =&gt; Set[String];
[error]   method tickets of type =&gt; collection.Set[String] has incompatible type
[error]     def tickets : Set[String] = Set("Alice", "Bob", "Carol")
[error]         ^
Error compiling project (Scala 3.3.1, JVM)
</code></pre>
   <p>The issue is that <code>Set</code> is defined in four places:</p>
   <ul>
    <li>unqualified in <code>scala.Predef</code></li>
    <li>as <code>scala.collection.Set</code></li>
    <li>as <code>scala.collection.immutable.Set</code></li>
    <li>as <code>scala.collection.mutable.Set</code>.</li>
   </ul>
   <p>The convenient, simple, unqualified <code>Set</code> is, very sensibly, just a type alias for <code>scala.collection.immutable.Set</code>.</p>
   <p>However, after I've imported <code>scala.collection.*</code>, unqualified <code>Set</code> now refers to <code>scala.collection.Set</code>, the base trait for <em>both</em> mutable and immutable sets, rather than the immutable trait it originally referred to.</p>
   <p>A <code>scala.collection.Set</code> is not a subtype of <code>scala.collection.immutable.Set</code> or, equivalently, the predef's unqualified <code>Set</code>.</p>
   <p>So even though my definition of a <code>Hat</code> looks trivially conformant, it is not.</p>
   <p>It's easy to fix this just by using the longhand syntax I prefer</p>
   <pre><code class="language-scala">  val hat = new Hat:
    def tickets : immutable.Set[String] = immutable.Set("Alice", "Bob", "Carol")
</code></pre>
   <p>But it's a bit surprising that a contract that was defined in terms of unqualified <code>Set</code> has to be implemented in terms of <code>immutable.Set</code>. If a trait was defined in terms of unqualified <code>Set</code>, it's more straightforward to just implement it in terms of that.</p>
   <p>So lately I've taken to changing how I make collections available for myself. I still prefer to be able to refer to them in explicit, clear, longhand. But instead of</p>
   <pre><code class="language-scala">import scala.collection.*
</code></pre>
   <p>I now prefer</p>
   <pre><code class="language-scala">import scala.collection.{immutable,mutable}
</code></pre>
   <p>This way, I can refer to collections explicitly as <code>immutable.Whatever</code> or <code>mutable.Whatever</code>, but when I refer to unqualified collection names, I haven't shadowed the predef definitions with rarely desired ambidextrous trait definitions under <code>scala.collection</code>.</p>
   <p>So now I have</p>
   <pre><code class="language-scala">//&gt; using scala 3.3.1

trait Hat:
  def tickets : Set[String]

object HatApp:
  import scala.collection.{immutable,mutable}
  import scala.util.Random

  val hat = new Hat:
    def tickets : Set[String] = Set("Alice", "Bob", "Carol")

  @main  
  def winner = println( Random.shuffle(hat.tickets.toList).head )
</code></pre>
   <p>and everything works as expected.</p>
   <p>The import is superfluous, gratuitous, unnecessary in this case. Since the only collection I touch is the unqualified <code>Set</code>, I could just have omitted any import.</p>
   <p>But collections are very common to use. In real applications, one very often wants to set up ones files for clear, easy access to them. I think this is a good syntax to use, that lets on both write out clear collection names and avoid surprising ambiguities.</p>
  </div>
 </div>
 <div class="entry-footer">
  <div class="post-metainfo">
   <hr>
   <div>
    by Steve Randy Waldman on 2023-10-07 @ <a href="https://tech.interfluidity.com/2023/10/07/referring-to-scala-collections/index.html" class="pubtime">05:45 PM EDT</a>
   </div>
  </div>
 </div>
</article>
<div class="after-article">
</div><!-- after-article -->]]>
      </content:encoded>
    </item>
  </channel>
</rss>
