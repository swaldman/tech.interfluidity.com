<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="description" content="tech notebook @ interfluidity">
    <meta name="keywords" content="Scala, tech, interfluidity">
    <meta name="author" content="Steve Randy Waldman">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- icons / favicons -->

    <!-- we just want the squared-corner image with no overlays for traditional favicon uses at tiny sizes -->
    <!-- swaldman added, ick, firefox scales down the biggest size for its tab icon, so we use the graphic we want for small sizes as the largest... -->
    <link rel="icon" type="image/png" sizes="500x500" href="../../../../icon/interfluidity-wave-blank-square-500x500.png"> 
    <link rel="icon" type="image/png" sizes="32x32" href="../../../../icon/interfluidity-wave-blank-square-32x32.png">     <!-- swaldman added, for standard favicon size -->
    <link rel="icon" type="image/png" sizes="16x16" href="../../../../icon/interfluidity-wave-blank-square-16x16.png">     <!-- swaldman added, for standard favicon size -->
    <link rel="icon" type="image/png" href="../../../../icon/interfluidity-wave-blank-square-57x57.png">                   <!-- swaldman added, for small icons by default -->

    <!-- at bigger sizes, we overlay a bit of text -->
    <!-- icons as recommened by https://mathiasbynens.be/notes/touch-icons -->
    <!-- For Chrome for Android: -->
    <link rel="icon" sizes="192x192" href="../../../../icon/interfluidity-wave-tech-192x192.png">
    <!-- For iPhone 6 Plus with @3× display: -->
    <link rel="apple-touch-icon-precomposed" sizes="180x180" href="../../../../icon/interfluidity-wave-tech-180x180.png">
    <!-- For iPad with @2× display running iOS ≥ 7: -->
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../../../icon/interfluidity-wave-tech-152x152.png">
    <!-- For iPad with @2× display running iOS ≤ 6: -->
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../../../../icon/interfluidity-wave-tech-144x144.png">
    <!-- For iPhone with @2× display running iOS ≥ 7: -->
    <link rel="apple-touch-icon-precomposed" sizes="120x120" href="../../../../icon/interfluidity-wave-tech-120x120.png">
    <!-- For iPhone with @2× display running iOS ≤ 6: -->
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../../../../icon/interfluidity-wave-tech-114x114.png">
    <!-- For the iPad mini and the first- and second-generation iPad (@1× display) on iOS ≥ 7: -->
    <link rel="apple-touch-icon-precomposed" sizes="76x76" href="../../../../icon/interfluidity-wave-tech-76x76.png">
    <!-- For the iPad mini and the first- and second-generation iPad (@1× display) on iOS ≤ 6: -->
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../../../../icon/interfluidity-wave-tech-72x72.png">
    <!-- For non-Retina iPhone, iPod Touch, and Android 2.1+ devices: -->
    <link rel="apple-touch-icon-precomposed" href="../../../../icon/interfluidity-wave-blank-square-57x57.png">

    <!-- end icons / favicons -->
    
    <link rel="alternate" type="application/rss+xml" title="tech.interfluidity.com updates" href="../../../../feed/index.rss">
    <link rel="alternate" type="application/x-all-item-rss+xml" title="tech.interfluidity.com - all items" href="https://tech.interfluidity.com/all-item-feed/index.rss">
    <link rel="alternate" type="application/rss+xml" title="interfluidity - all blogs" href="https://www.interfluidity.com/unify-rss/all-blogs.rss">
    <link rel="alternate" type="application/rss+xml" title="interfluidity - all blogs and microblogs" href="https://www.interfluidity.com/unify-rss/all-blogs-and-microblogs.rss">
    <link rel="alternate" type="application/x-single-item-rss+xml" title="Referring to Scala collections" href="index.rss">
    <link rel="stylesheet" href="../../../../css/style.css">
    <link rel="stylesheet" href="../../../../css/highlightjs/steve-night-owl.css"><!-- theme for highlight.js -->
    <script src="../../../../js/highlight/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script>
      document.addEventListener("DOMContentLoaded", function() {
          const regex = /(^.*)\-oldcommit\-[0-9A-Fa-f]+\.html/;
          const match = window.location.pathname.match(regex);
          if (match) {
              const b  = document.querySelector("body");
              const tb = document.getElementById("top-banner");
              b.classList.add("old-draft");
              tb.innerHTML = "You are looking at an old, superceded version of this page. For the current version, please <a href=\"" + match[1] + ".html\">click here</a>.";
          }
       });
    </script>
    <title>Referring to Scala collections</title>
  </head>
  <body>
    <div id="top-banner"></div>
    <div id="header">
      <div id="rss-link-container">
        <a id="rss-link" href="../../../../feed/index.rss"><span class="outer">(</span><span class="middle">(</span><span class="inner">(</span><span class="bullet">&bull;</span><span class="inner">)</span><span class="middle">)</span><span class="outer">)</span></a>
      </div>
      <div class="main-title"><a href="https://tech.interfluidity.com/">tech.interfluidity.com</a></div>
      <div class="tagline">a notebook by <a href="https://www.interfluidity.com/">steve&nbsp;randy&nbsp;waldman</a></div>
      <div class="see-also">&rarr; See also <a href="../../../../index.html">top</a>, <a href="../../../../archive.html">archive</a>, <a href="../../../../subscribe.html">subscribe</a>, <a href="https://drafts.interfluidity.com/">drafts blog</a>, <a href="https://www.interfluidity.com/">interfluidity main</a></div>
    </div>
    <div id="main">
      <div id="left-sidebar">
      </div>
      <div id="content">
        <div class="day-stamp">
 2023-10-07 <span class="arrow">⇒</span>
</div>
<article class="presentation-single">
 <div class="entry-header">
  <h1><a href="index.html">Referring to Scala collections</a></h1>
  <hr class="below-title">
 </div>
 <div class="entry-body">
  <div class="flexmark markdown">
   <p><strong>TL; DR:</strong> Prefer</p>
   <pre><code class="language-scala">import scala.collection.{immutable,mutable}
</code></pre>
   <hr>
   <p>Over the eons, I developed a habit of using the following import</p>
   <pre><code class="language-scala">import scala.collection.*
</code></pre>
   <p>to set up my use of Scala collections.</p>
   <p>Then I can refer to collections in a very clear longhand. For example:</p>
   <pre><code class="language-scala">val alphamap = immutable.Map( "A" -&gt; "Apple", "B" -&gt; "Baby", "C" -&gt; "Candy" )
</code></pre>
   <p>or, much less frequently:</p>
   <pre><code class="language-scala">val scratchpad = mutable.Map( "Title" -&gt; "Untitled" )
</code></pre>
   <p>I <em>like</em> referring explicitly to collections as <code>mutable.Thing</code> or <code>immutable.Thing</code>. Yes it's more typing, but it's very clear.</p>
   <p>But recently the practice has caused some hassles, and I've realized it's not great.</p>
   <p>Consider this little <a href="https://scala-cli.virtuslab.org/">scala-cli</a> application:</p>
   <pre><code class="language-scala">//&gt; using scala 3.3.1

trait Hat:
  def tickets : Set[String]

object HatApp:
  import scala.collection.*
  import scala.util.Random

  val hat = new Hat:
    def tickets : Set[String] = Set("Alice", "Bob", "Carol")

  @main  
  def winner = println( Random.shuffle(hat.tickets.toList).head )
</code></pre>
   <p>Try running it, and oops!</p>
   <pre><code class="language-plaintext">Compiling project (Scala 3.3.1, JVM)
[error] ./unqualified-collections.scala:11:9
[error] error overriding method tickets in trait Hat of type =&gt; Set[String];
[error]   method tickets of type =&gt; collection.Set[String] has incompatible type
[error]     def tickets : Set[String] = Set("Alice", "Bob", "Carol")
[error]         ^
Error compiling project (Scala 3.3.1, JVM)
</code></pre>
   <p>The issue is that <code>Set</code> is defined in four places:</p>
   <ul>
    <li>unqualified in <code>scala.Predef</code></li>
    <li>as <code>scala.collection.Set</code></li>
    <li>as <code>scala.collection.immutable.Set</code></li>
    <li>as <code>scala.collection.mutable.Set</code>.</li>
   </ul>
   <p>The convenient, simple, unqualified <code>Set</code> is, very sensibly, just a type alias for <code>scala.collection.immutable.Set</code>.</p>
   <p>However, after I've imported <code>scala.collection.*</code>, unqualified <code>Set</code> now refers to <code>scala.collection.Set</code>, the base trait for <em>both</em> mutable and immutable sets, rather than the immutable trait it originally referred to.</p>
   <p>A <code>scala.collection.Set</code> is not a subtype of <code>scala.collection.immutable.Set</code> or, equivalently, the predef's unqualified <code>Set</code>.</p>
   <p>So even though my definition of a <code>Hat</code> looks trivially conformant, it is not.</p>
   <p>It's easy to fix this just by using the longhand syntax I prefer</p>
   <pre><code class="language-scala">  val hat = new Hat:
    def tickets : immutable.Set[String] = immutable.Set("Alice", "Bob", "Carol")
</code></pre>
   <p>But it's a bit surprising that a contract that was defined in terms of unqualified <code>Set</code> has to be implemented in terms of <code>immutable.Set</code>. If a trait was defined in terms of unqualified <code>Set</code>, it's more straightforward to just implement it in terms of that.</p>
   <p>So lately I've taken to changing how I make collections available for myself. I still prefer to be able to refer to them in explicit, clear, longhand. But instead of</p>
   <pre><code class="language-scala">import scala.collection.*
</code></pre>
   <p>I now prefer</p>
   <pre><code class="language-scala">import scala.collection.{immutable,mutable}
</code></pre>
   <p>This way, I can refer to collections explicitly as <code>immutable.Whatever</code> or <code>mutable.Whatever</code>, but when I refer to unqualified collection names, I haven't shadowed the predef definitions with rarely desired ambidextrous trait definitions under <code>scala.collection</code>.</p>
   <p>So now I have</p>
   <pre><code class="language-scala">//&gt; using scala 3.3.1

trait Hat:
  def tickets : Set[String]

object HatApp:
  import scala.collection.{immutable,mutable}
  import scala.util.Random

  val hat = new Hat:
    def tickets : Set[String] = Set("Alice", "Bob", "Carol")

  @main  
  def winner = println( Random.shuffle(hat.tickets.toList).head )
</code></pre>
   <p>and everything works as expected.</p>
   <p>The import is superfluous, gratuitous, unnecessary in this case. Since the only collection I touch is the unqualified <code>Set</code>, I could just have omitted any import.</p>
   <p>But collections are very common to use. In real applications, one very often wants to set up ones files for clear, easy access to them. I think this is a good syntax to use, that lets on both write out clear collection names and avoid surprising ambiguities.</p>
  </div>
 </div>
 <div class="entry-footer">
  <div class="post-metainfo">
   <div>
    <a href="index.html" class="pubtime">05:45 PM EDT</a>
   </div>
  </div>
 </div>
</article>
<div class="after-article">
 <div class="prev-top-next">
  <div class="prev">
   <a href="../../../09/17/taking-control-of-podcasts-via-rss/index.html">← Taking control of podcasts via RSS</a>
  </div>
  <div class="top">
   <a href="../../../../index.html">↑↑↑</a>
  </div>
  <div class="next">
   <a href="../../09/contributing-to-mill/index.html">Contributing to mill →</a>
  </div>
 </div>
</div>
<!-- after-article -->
      </div>
      <div id="right-sidebar">
      </div>
    </div>
  </body>
</html>
