<?xml version='1.0' encoding='UTF-8'?>
<rss 
version="2.0" xmlns:iffy="http://tech.interfluidity.com/xml/iffy/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>tech — interfluidity</title>
    <link>https://tech.interfluidity.com/index.html</link>
    <description><![CDATA[Feed for blog 'tech — interfluidity', generated by unstatic]]></description>
    <language>en-us</language>
    <lastBuildDate>Tue, 28 Jan 2025 22:06:10 -0500</lastBuildDate>
    <generator>https://github.com/swaldman/unstatic</generator>
    <docs>https://cyber.harvard.edu/rss/rss.html</docs>
    <atom:link
    type="application/rss+xml" rel="self" href="https://tech.interfluidity.com/2023/07/29/building-a-resilient-rss-feed-unifier-with-zio/index.rss"/>
    <iffy:curation>
      <iffy:single/>
    </iffy:curation>
    <iffy:completeness>Content</iffy:completeness>
    <item>
      <pubDate>Sat, 29 Jul 2023 10:20:00 -0400</pubDate>
      <guid isPermalink="true">
        https://tech.interfluidity.com/2023/07/29/building-a-resilient-rss-feed-unifier-with-zio/index.html
      </guid>
      <description>
        <![CDATA[Functional effect libraries are an important part of the Scala ecosystem, so I've been playing with them for a while. The static-site generator that produces this site, as well as the templating engine that underlies it are both built with ZIO. But in both those projects, I've quietly wondered whether whatever benefit I get from working through functional effects outweighs the extra ceremony and abstraction it requires. One likes to keep up with the times, sure, but is the new thing progress or...]]>
      </description>
      <link>https://tech.interfluidity.com/2023/07/29/building-a-resilient-rss-feed-unifier-with-zio/index.html</link>
      <title>Building a resilient RSS feed unifier with ZIO</title>
      <dc:creator><![CDATA[Steve Randy Waldman]]></dc:creator>
      <content:encoded>
        <![CDATA[<article class="presentation-rss uid-resilient-RSS-feed-unifier">
 <div class="entry-header">
 </div>
 <div class="entry-body">
  <div class="flexmark markdown">
   <p>Functional effect libraries are an important part of the Scala ecosystem, so I've been playing with them for a while. The <a href="https://github.com/swaldman/unstatic">static-site generator that produces this site</a>, as well as the <a href="https://github.com/swaldman/untemplate-doc">templating engine</a> that underlies it are both built with ZIO.</p>
   <p>But in both those projects, I've quietly wondered whether whatever benefit I get from working through functional effects outweighs the extra ceremony and abstraction it requires. One likes to keep up with the times, sure, but is the new thing progress or merely fashion?</p>
   <p>I now spread my writing over <a href="https://www.interfluidity.com/">several</a> <a href="https://drafts.interfluidity.com/">blogs</a> <a href="https://tech.interfluidity.com/">and</a> <a href="https://econtwitter.net/@interfluidity">microblogs</a>. A few days ago, I decided to write a service to unify the sites' several RSS feeds into a convenient single feed for all of my writing. (Actually two feeds: <a href="https://www.interfluidity.com/unify-rss/all-blogs.rss"><code>all-blogs.rss</code></a> and <a href="https://www.interfluidity.com/unify-rss/all-blogs-and-microblogs.rss"><code>all-blogs-and-microblogs.rss</code></a>) The service needs periodically to load source feeds from each of the several sites, then merge them into a single RSS document and stand ready to serve them to subscribers.</p>
   <p>The project is <a href="https://github.com/swaldman/unify-rss"><code>unify-rss</code></a> on github.</p>
   <p>It's a pretty trivial application, but it does need to be fault tolerant. It oughtn't break if, for example, one of the source feeds go down.</p>
   <p>Error-handling / retry logic needn't complicated, but in my experience it often becomes verbose. It can render core "happy path" functionality less clear and readable, and make applications more complicated to maintain. But ZIO really shines at concisely "transforming effects", so that retry logic mostly stays out of the way. This was the first project where I was sure the extra indirection of functional effects was "worth it".</p>
   <p>Simplifying, the basic logic of the application looks like this:</p>
   <pre><code class="language-scala">import scala.collection.*
import scala.xml.{Elem, XML}
import java.net.URL
import zio.*

// this is much simpler than the real AppConfig!
case class AppConfig( sourceUrls : immutable.Seq[URL], refreshSeconds : Int )

def fetchFeed(url : URL) : Task[Elem] =
  ZIO.attemptBlocking(XML.load(url))

def fetchFeeds(urls : Iterable[URL]) : Task[immutable.Seq[Elem]] =
  ZIO.collectAllPar(Chunk.fromIterable(urls.map(fetchFeed)))

def mergeFeeds( config : AppConfig, elems : immutable.Seq[Elem] ) : Task[immutable.Seq[Byte]] = ???

def initMergeFeed( config : AppConfig ) : Task[Ref[immutable.Seq[Byte]]]  =
  for
    elems &lt;- fetchFeeds( config.sourceUrls )
    feed  &lt;- mergeFeeds( config, elems )
    ref   &lt;- Ref.make(feed)
  yield ref

def updateMergedFeed( config : AppConfig, ref : Ref[immutable.Seq[Byte]] ) : Task[Unit] =
  for
    elems &lt;- fetchFeeds( config.sourceUrls )
    feed  &lt;- mergeFeeds( config, elems )
    _     &lt;- ref.set(feed)
  yield ()

def periodicallyUpdateMergedFeed( config : AppConfig, ref : Ref[immutable.Seq[Byte]] ) : Task[Long] =
  updateMergedFeed( config, ref ).schedule( Schedule.fixed( Duration.fromSeconds(config.refreshSeconds) ) )

// use tapir withh http-zio to create an effect starting a web endpoint that serves RSS from the ref
def server(ac : AppConfig, ref : Ref[immutable.Seq[Byte]] ) : UIO[ExitCode] = ???

object Main extends ZIOAppDefault:
  val config : AppConfig = ???

  override def run =
    for
      ref      &lt;- initMergeFeed( config )
      _        &lt;- periodicallyUpdateMergedFeed( config, ref ).forkDaemon
      exitCode &lt;- server( config, ref )
    yield exitCode
</code></pre>
   <p>It's super simple. We set up a thread-safe (well, um, fiber-safe) <a href="https://javadoc.io/doc/dev.zio/zio_3/latest/zio/Ref.html"><code>zio.Ref</code></a> to hold the initial merged feed, then we fork a separate fiber to run an effect that periodically updates the <code>Ref</code>, then we start up an http service that serves the contents of the ref.</p>
   <p>The super concise refresh loop logic was definitely a ZIO advantage.</p>
   <pre><code class="language-scala">updateMergedFeed( config, ref ).schedule( Schedule.fixed( Duration.fromSeconds(config.refreshSeconds) ) )
</code></pre>
   <p>But we are not resilient yet! What if <code>updateMergedFeed(...)</code> fails? For now the effect would just end, and our server would break. An RSS feed that never updates is worse than no RSS feed at all.</p>
   <p>But, with ZIO it is trivial to solve this problem. We just define a retry <a href="https://javadoc.io/doc/dev.zio/zio_3/latest/zio/Schedule.html"><code>Schedule</code></a>, and have the update attempt retry until it hopefully, eventually, succeeds.</p>
   <pre><code class="language-scala">def retrySchedule( config : AppConfig ) =
  Schedule.exponential( 10.seconds, 1.5d ) || Schedule.fixed( Duration.fromSeconds( config.refreshSeconds ) ) 

def periodicallyUpdateMergedFeed( config : AppConfig, ref : Ref[immutable.Seq[Byte]] ) : Task[Long] =
  val resilient = updateMergedFeed( config, ref ).schedule( retrySchedule( config ) )
  resilient.schedule( Schedule.fixed( Duration.fromSeconds(config.refreshSeconds) ) )
</code></pre>
   <p>This retry schedule will make a first retry attempt after 10 seconds, then after 15 seconds, then after (1.5<sup>2</sup> * 10 =) 22.5 seconds, etc. — retrying less and less often but no less often than the configured refresh frequency for the unified feed.</p>
   <p>Cool! Now our application won't break if any part of an update attempt fails, but will sensibly retry until it succeeds.</p>
   <p>But.</p>
   <p>What if it never does succeed? What if just one of the several source feeds getting merged goes fairly permanently down? Should that prevent the merged feed from updating indefinitely?</p>
   <p>I decided that it should not, and that instead if a single feed is unavailable, we should just omit its items and merge the rest. So, we revise...</p>
   <pre><code class="language-scala">def fetchFeed(url : URL) : Task[Option[Elem]] =
  ZIO.attemptBlocking(XML.load(url))
    .foldCauseZIO(
      cause =&gt; ZIO.logCause(s"Problem loading feed '${url}'", cause) *&gt; ZIO.succeed(None),
      elem =&gt; ZIO.succeed(Some(elem))
    )

def fetchFeeds(urls : Iterable[URL]) : Task[immutable.Seq[Elem]] =
  ZIO.collectAllPar(Chunk.fromIterable(urls.map(fetchFeed)))
    .map( _.collect { case Some(elem) =&gt; elem } )
</code></pre>
   <p>Now we recover from an individual feed-fetch failure, and return an <code>Option</code>, <code>Some(elem)</code> on success, <code>None</code> otherwise. We then collect the successes and build our merged feed from those.</p>
   <p>But maybe we should retry our update attempts for a source feed before returning <code>None</code>, in case there's a very transient hitch?</p>
   <pre><code class="language-scala">def fetchFeed(url : URL) : Task[Option[Elem]] =
  ZIO.attemptBlocking(XML.load(url))
    .retry( Schedule.spaced( 6.seconds ).upTo( 60.seconds ) )
    .foldCauseZIO(
      cause =&gt; ZIO.logCause(s"Problem loading feed '${url}'", cause) *&gt; ZIO.succeed(None),
      elem =&gt; ZIO.succeed(Some(elem))
    )
</code></pre>
   <p>Great! Now we'll try a source feed for up to a minute before giving up on it.</p>
   <p>The actual application is more complicated than this, mostly because instead of serving just a single merged feed, it permits you to configure any number of feeds to merge from different groups of source feeds. So, for example, where we have a <code>Ref</code> in the logic above, <code>unify-rss</code> has a <code>Map</code> of feed paths to <code>Ref</code>. The logic has to update all the <code>Ref</code>s, rather than just a single one, periodically.</p>
   <p>But that's just book-keeping. At its core, this was a pretty simple app. With ZIO the logic could be expressed safely and concisely, and it was easy to evolve the app from an initial, brittle sketch to one that should be resilient as a permanent service.</p>
   <hr>
   <p><em>Note: I recently went through <a href="https://rockthejvm.com/p/zio">Daniel Ciocîrlan's ZIO 2 video course</a>, which was very, very helpful for this project. Highly recommended!</em></p>
   <hr>
   <p><strong>Update 2023-11-10:</strong> I've added to this app functionality to generate feeds as static files, rather than to serve them from memory as a (resilient!) daemon. That saves some memory and overhead on the server side. Instead of periodically updating feeds in the app, now we just define a <a href="https://github.com/swaldman/unify-rss/blob/interfluidity/unify-rss.timer"><code>systemd</code> timer</a> to rerun a static-file generating version of the app every half hour. It's a less sexy app somehow, this way, but a bit simpler and conserves memory.</p>
   <p>We still do the retries described above, when feeds fail to load. But we let <code>systemd</code> take care of the periodic regeneratios.</p>
   <p>See the current <a href="https://github.com/swaldman/unify-rss/blob/main/README.md"><code>README</code></a> for more information.</p>
  </div>
 </div>
 <div class="entry-footer">
  <div class="post-metainfo">
   <hr>
   <div>
    by Steve Randy Waldman on 2023-07-29 @ <a href="https://tech.interfluidity.com/2023/07/29/building-a-resilient-rss-feed-unifier-with-zio/index.html" class="pubtime">10:20 AM EDT</a>
   </div>
  </div>
 </div>
</article>
<div class="after-article">
</div><!-- after-article -->]]>
      </content:encoded>
    </item>
  </channel>
</rss>
