<?xml version='1.0' encoding='UTF-8'?>
<rss 
version="2.0" xmlns:iffy="http://tech.interfluidity.com/xml/iffy/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>tech — interfluidity</title>
    <link>https://tech.interfluidity.com/index.html</link>
    <description><![CDATA[Feed for blog 'tech — interfluidity', generated by unstatic]]></description>
    <language>en-us</language>
    <lastBuildDate>Thu, 22 May 2025 18:31:18 -0400</lastBuildDate>
    <generator>https://github.com/swaldman/unstatic</generator>
    <docs>https://cyber.harvard.edu/rss/rss.html</docs>
    <atom:link
    type="application/rss+xml" rel="self" href="https://tech.interfluidity.com/2024/03/18/c3p0-and-loom/index.rss"/>
    <iffy:curation>
      <iffy:single/>
    </iffy:curation>
    <iffy:completeness>Content</iffy:completeness>
    <item>
      <pubDate>Mon, 18 Mar 2024 22:20:00 -0400</pubDate>
      <guid isPermalink="true">https://tech.interfluidity.com/2024/03/18/c3p0-and-loom/index.html</guid>
      <description>
        <![CDATA[I write a lot of open source software, but I've only ever really had one "hit". That makes me pretty sad, actually. I think some of what I've written is pretty great, and it's lonesome to be the sole user. Nevertheless, my one "hit" was c3p0, a JDBC Connection pool that, in its day, was extremely popular in Java web application stacks. Its day was a long time ago, though! c3p0 was first released on Sourceforge in 2001, and was very widely used from the mid aughts through the early 2010s. c3p0...]]>
      </description>
      <link>https://tech.interfluidity.com/2024/03/18/c3p0-and-loom/index.html</link>
      <title>c3p0 and loom</title>
      <dc:creator><![CDATA[Steve Randy Waldman]]></dc:creator>
      <content:encoded>
        <![CDATA[<article class="presentation-rss uid-c3p0-and-loom">
 <div class="entry-header">
 </div>
 <div class="entry-body">
  <div class="flexmark markdown">
   <p>I write <a href="https://github.com/swaldman">a lot of open source software</a>, but I've only ever really had one "hit". That makes me pretty sad, actually. I think some of what I've written is pretty great, and it's lonesome to be the sole user.</p>
   <p>Nevertheless, my one "hit" was <a href="https://www.mchange.com/projects/c3p0/">c3p0</a>, a JDBC Connection pool that, in its day, was extremely popular in Java web application stacks.</p>
   <p>Its day was a long time ago, though! c3p0 was first released <a href="https://sourceforge.net/projects/c3p0/files/historical/OldFiles/">on Sourceforge in 2001</a>, and was very widely used from the mid aughts through the early 2010s.</p>
   <p>c3p0 is "mature" software, and I have just let it alone for years at a time. But I do continue to use it in all of my own database projects. Periodically I still put it (and myself) through intense bouts of maintenance.</p>
   <p>Actually, I have hated my years-long lapses (and myself) because github issues collect and I get snarky comments about abandonware and I feel like I am a Very Bad Maintainer. So the first order of business in my most recent "sprint" (isn't that what the kids call it?) was to move c3p0 from a very bespoke and manual <a href="https://ant.apache.org/">ant</a> build to something sleek and modern and automatic, so that maybe I wouldn't put off maintenance into years-delayed batches just because it is annoying to touch. c3p0's new <a href="https://mill-build.com/mill/Intro_to_Mill.html">mill build</a> works beautifully.</p>
   <p>The new build is much lighter, and the modern style of just publishing git repositories rather than source distributions and uploading releases to Sonatype is fast and easy. I think it'll really improve my maintenance promptness.</p>
   <p>c3p0's latest release, <a href="https://github.com/swaldman/c3p0/blob/0.10.x/RELEASE_NOTES-c3p0-0.10.0">0.10.0</a>, includes lots of enhancements and improvements. But a really fun thing was to integrate the very latest shiny new thing in Java — "Project Loom" <a href="https://docs.oracle.com/en/java/javase/21/core/virtual-threads.html">virtual threads</a> — into this very old, highly concurrent library.</p>
   <p>c3p0 is very old school. It was initially written in Java 1.2 or 1.3. Java's standard concurrency utilities, the <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/package-summary.html"><code>java.util.concurrent</code></a> package, did not yet exist. There were no standard thread pools defined as <a href="https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/util/concurrent/Executors.html"><code>ExecutorService</code> implementations</a>. So I <a href="https://github.com/swaldman/mchange-commons-java/blob/master/src/main/java/com/mchange/v2/async/ThreadPoolAsynchronousRunner.java">rolled my own</a>. c3p0 relies entirely on the JVM's built-in primitives — monitors and <code>synchronized</code> blocks, <code>wait()</code> and <code>notifyAll()</code> — to manage concurrency.</p>
   <p>Over the years, people have requested that c3p0 support asynchroneity via pluggable <code>Executor</code> instances, rather than just its own, hand-rolled thread pool. Users mostly seemed to want this so c3p0 could share existing application thread pools, avoiding the resource footprint of several c3p0-dedicated threads.</p>
   <p>A couple of weeks ago, I finally got around to implementing <a href="https://www.mchange.com/projects/c3p0/#configuring_threading">pluggable threading</a>. Sharing application thread pools is now supported. But I was mostly motivated by curiousity about how well this very old library would work with newfangled loom virtual threads.</p>
   <p>Great, it turns out!</p>
   <ul>
    <li>
     <p>I was concerned, since c3p0 relies so much on monitors and <code>synchronized</code> blocks, that virtual threads would be "pinned". Virtual threads are scheduled to, and deschedule from, "carrier" operating-system threads, but they cannot be descheduled while they hold a monitor. If a thread blocks while holding a monitor, it is described as "pinned", and that's a bad thing.</p>
     <p>But c3p0 is very careful not to perform potentially blocking operations while holding a monitor. Running tests with</p>
     <pre><code class="language-plaintext">-Djdk.tracePinnedThreads=full
</code></pre>
     <p>produced no stack traces of pinned threads, even under heavy load. This was gratifying.</p></li>
    <li>
     <p>Using virtual threads rather than a thread pool can reduce contention for monitors. The thread pool itself is a site of contention, as information about which threads are pooled and which are available to run tasks constitute shared, mutable state. Replacing a thread pool with simply firing and forgetting a virtual thread for each asynchrnous task left nothing to contend for. <a href="https://github.com/swaldman/c3p0-loom"><code>c3p0-loom</code></a> includes two implementations of <a href="https://www.mchange.com/projects/c3p0/apidocs/com/mchange/v2/c3p0/TaskRunnerFactory.html"><code>TaskRunnerFactory</code></a>:</p>
     <ul>
      <li><a href="https://github.com/swaldman/c3p0-loom/blob/main/src/com/mchange/v2/c3p0/loom/UninstrumentedVirtualThreadPerTaskTaskRunnerFactory.java"><code>com.mchange.v2.c3p0.loom.UninstrumentedVirtualThreadPerTaskTaskRunnerFactory</code></a></li>
      <li><a href="https://github.com/swaldman/c3p0-loom/blob/main/src/com/mchange/v2/c3p0/loom/VirtualThreadPerTaskExecutorTaskRunnerFactory.java"><code>com.mchange.v2.c3p0.loom.VirtualThreadPerTaskExecutorTaskRunnerFactory</code></a></li>
     </ul>
     <p><code>com.mchange.v2.c3p0.loom.VirtualThreadPerTaskExecutorTaskRunnerFactory</code> tracks the number of simultaneously active threads (which you can observe via JMX), which involve synchronizing on a monitor so some contention is still possible.</p>
     <p>But with <code>com.mchange.v2.c3p0.loom.UninstrumentedVirtualThreadPerTaskTaskRunnerFactory</code>, nothing at all is tracked and no monitors are acquired. Some analog of contention might result from managing shared state within the loom virtual-threading runtime, but all overt contention for thread-pool monitors is eliminated.</p></li>
   </ul>
   <p>In practice, the thread pool is not c3p0's main site of monitor contention, however.</p>
   <p>c3p0's <a href="https://github.com/swaldman/c3p0/blob/0.10.x/src/com/mchange/v2/resourcepool/BasicResourcePool.java">resource pool</a> is its main site of monitor contention. For most applications, the contention overhead is negligible, when amortized over <code>Connection</code> operations. But in rare cases, when very large numbers of threads are hitting the pool, contention can become an issue. For now, the only way to address contention at the resource pool is to construct multiple <code>DataSource</code> instances and balance the load across them.</p>
   <p>In any case, c3p0 and loom work very well together!</p>
   <p>I still recommend that applications start by using c3p0's default, hand-rolled thread pool. It implements deadlock detection and recovery, and logs verbose debugging information about what happened. This makes it very easy to diagnose what kinds of operations have been hanging and consuming threads when something goes wrong.</p>
   <p>Under loom, applications that might otherwise have logged flamboyant thread-pool problems will proceed gracefully for some time. No matter what operations hang, new (virtual) threads will always be available for the next request, and the memory footprint of the frozen "fibers" (rather than full threads) should be modest.</p>
   <p>But if <code>Connection</code> acquisition, <code>Connection</code> destruction, or <code>Statement</code> destruction tasks do hang, eventually the pool will become exhausted and your application will hang or fail, despite the almost inexhaustible virtual threads.</p>
   <p>I'd start by using c3p0's default, battle-tested thread pool to detect these kinds of issues, and log them with its signature, much-hated <code>APPARENT DEADLOCK</code> messages if they occur. Those very ugly <code>APPARENT DEADLOCK</code> messages make it very easy to figure out just what is going wrong.</p>
   <p>But once your application is stable, then you might absolutely consider setting</p>
   <pre><code class="language-plaintext">c3p0.taskRunnerFactoryClassName=com.mchange.v2.c3p0.loom.UninstrumentedVirtualThreadPerTaskTaskRunnerFactory
</code></pre>
   <p>to reduce monitor contention and eliminate the overhead of a dedicated c3p0 thread pool.</p>
   <hr>
   <p><strong>Note:</strong></p>
   <p>The latest version of c3p0 (as of this writing) is <code>0.10.0</code>. Ordinarily, you'd hit that at Maven Central as</p>
   <ul>
    <li><code>com.mchange:c3p0:0.10.0</code></li>
   </ul>
   <p>But c3p0 is built under older Java version, to support old applications. (c3p0-0.10.0 supports JVMs as old as Java 7.)</p>
   <p>Loom support has to be built under Java 21+, so it is built separately. Just hit</p>
   <ul>
    <li><code>com.mchange:c3p0-loom:0.10.0</code></li>
   </ul>
   <p>at Maven Central. That will bring in the loom implementations, and the rest of c3p0 as a transitive dependency.</p>
  </div>
 </div>
 <div class="entry-footer">
  <div class="post-metainfo">
   <hr>
   <div>
    by Steve Randy Waldman on 2024-03-18 @ <a href="https://tech.interfluidity.com/2024/03/18/c3p0-and-loom/index.html" class="pubtime">10:20 PM EDT</a>
   </div>
  </div>
 </div>
</article>
<div class="after-article">
</div><!-- after-article -->]]>
      </content:encoded>
    </item>
  </channel>
</rss>
